David Miller | djm545
Lab 8

Q1.1)
// Purpose: Takes, as an argument, the number of seconds since midnight, and returns the time of day.
// Preconditions: An integer that represents a number of seconds past.
// Postconditions: A structure time, that has attributes: hr, min, seconds, to represent the time of day the given
// 						number of seconds represent.
struct time sec2hms( int secs ) {
	struct time out;
	out.hr = secs / 3600;
	secs = secs % 3600;
	out.min = secs / 60;
	out.sec = secs % 60;

	return out;
}

Q1.2)
// Purpose: Takes a file to parse and an array to allocate space for and create people based off of file contents.
// Preconditions: This file is sequenced into triads of lines for a singular input.
// Postconditions: Modifies the inputted array with pointers to people who were created based off of input.
void readPeople( person* a[], FILE* f ) 
{
	char *buff = NULL ;
	size_t len ;
	size_t cnt = 0 ;

	while( getline( &buff, &len, f ) > 1 ) 
	{
		person* someone = (person*) malloc(sizeof(person));	
		
		sscanf(buff, "%s", someone->last);
		getline( &buff, &len, f );
		sscanf(buff, "%s", someone->first);
		getline( &buff, &len, f );
		sscanf(buff, "%d", &(someone->age));

		*(a+cnt) = someone;

		++cnt ;
	}

	free( buff ) ;
}


Q1.3)
// Purpose: Take an array of pointers to people and the array's size to free their allocated space.
// Preconditions: An array of pointers to people and the size of the array.
// Postconditions: Frees and unassigns every pointer within the array and the array itself.
void freePeople( person* a[], size_t n ) 
{	
	for (size_t i = 0; i < n; ++i) {
		if (*(a+i) != NULL) free(*(a+i));			
		*(a+i) = NULL;
	}	
	a = NULL;
}

Q2.1)
// Purpose: Write a function that takes a list, returns its length.
// Preconditions: Given a pointer to a structure sNode that contains an attribute to the next element in a list and
// 					assuming that this list does not contain any cycles.
// Postconditions: A size_t representing the length of the given list.
size_t listLength(const sNode *L){
	size_t len = 1;	
	while(L->next != NULL) {
		L = L->next;
		len++;
	}
	return len;
}

Q2.2)
// Purpose: Write a function that reverses a list, in place.
// Preconditions: Given a pointer to a structure sNode that contains an attribute to the next element in a list and
// 					assuming that this list does not contain any cycles.
// Postconditions: Reverses the order of the given list and returns the pointer to the first element.
sNode* listRev(sNode *L){
	sNode* current = L;
	sNode* previous = L;
	sNode* next = current->next;
	
	current->next = NULL;	
	current = next;

	while(current->next != NULL) {	
		next = current->next;
		current->next = previous;
		previous = current;
		current = next;
	}
	current->next = previous;
	return current;
}
